-- Phase 4: Pre-Computed ML Intelligence Schema
-- Stores ML-generated insights for MCP read-only access
-- Maintains strict architectural separation

-- ===================================
-- Pre-Computed Rule Intelligence Tables
-- ===================================

-- Store pre-computed rule effectiveness scores by prompt characteristics
CREATE TABLE IF NOT EXISTS rule_intelligence_cache (
    id SERIAL PRIMARY KEY,
    cache_key VARCHAR(255) UNIQUE NOT NULL, -- Hash of prompt characteristics
    rule_id VARCHAR(50) NOT NULL,
    rule_name VARCHAR(100) NOT NULL,
    
    -- Pre-computed scores (generated by ML system)
    effectiveness_score FLOAT NOT NULL CHECK (effectiveness_score >= 0 AND effectiveness_score <= 1),
    characteristic_match_score FLOAT NOT NULL CHECK (characteristic_match_score >= 0 AND characteristic_match_score <= 1),
    historical_performance_score FLOAT NOT NULL CHECK (historical_performance_score >= 0 AND historical_performance_score <= 1),
    ml_prediction_score FLOAT CHECK (ml_prediction_score >= 0 AND ml_prediction_score <= 1),
    recency_score FLOAT NOT NULL CHECK (recency_score >= 0 AND recency_score <= 1),
    total_score FLOAT NOT NULL CHECK (total_score >= 0 AND total_score <= 1),
    
    -- ML insights (JSONB for flexibility)
    pattern_insights JSONB,
    optimization_recommendations JSONB,
    performance_trend VARCHAR(20) CHECK (performance_trend IN ('improving', 'stable', 'declining')),
    
    -- Metadata
    confidence_level FLOAT NOT NULL CHECK (confidence_level >= 0 AND confidence_level <= 1),
    sample_size INTEGER NOT NULL DEFAULT 0,
    prompt_characteristics_hash VARCHAR(64) NOT NULL, -- For cache invalidation
    
    -- Timestamps
    computed_at TIMESTAMP NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL DEFAULT (NOW() + INTERVAL '6 hours'),
    last_accessed TIMESTAMP DEFAULT NOW(),
    access_count INTEGER DEFAULT 0,
    
    -- Foreign key
    FOREIGN KEY (rule_id) REFERENCES rule_metadata(rule_id) ON DELETE CASCADE
);

-- Store pre-computed rule combination recommendations
CREATE TABLE IF NOT EXISTS rule_combination_intelligence (
    id SERIAL PRIMARY KEY,
    combination_key VARCHAR(255) UNIQUE NOT NULL, -- Hash of rule set + characteristics
    rule_set JSONB NOT NULL, -- Array of rule IDs
    
    -- Pre-computed combination scores
    combined_effectiveness FLOAT NOT NULL CHECK (combined_effectiveness >= 0 AND combined_effectiveness <= 1),
    synergy_score FLOAT CHECK (synergy_score >= -1 AND synergy_score <= 1), -- Can be negative for conflicts
    individual_scores JSONB NOT NULL,
    
    -- ML-generated insights
    synergy_pairs JSONB, -- Pairs that work well together
    conflict_pairs JSONB, -- Pairs that conflict
    optimization_bonus FLOAT DEFAULT 0.0,
    
    -- Statistical validation
    sample_size INTEGER NOT NULL DEFAULT 0,
    statistical_confidence FLOAT NOT NULL CHECK (statistical_confidence >= 0 AND statistical_confidence <= 1),
    
    -- Context
    prompt_type VARCHAR(50),
    domain VARCHAR(50),
    complexity_range JSONB, -- Min/max complexity this applies to
    
    -- Timestamps
    computed_at TIMESTAMP NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL DEFAULT (NOW() + INTERVAL '12 hours'),
    last_accessed TIMESTAMP DEFAULT NOW(),
    access_count INTEGER DEFAULT 0
);

-- Store pre-computed pattern discovery results
CREATE TABLE IF NOT EXISTS pattern_discovery_cache (
    id SERIAL PRIMARY KEY,
    discovery_key VARCHAR(255) UNIQUE NOT NULL, -- Hash of discovery parameters
    
    -- Pattern analysis results
    parameter_patterns JSONB,
    sequence_patterns JSONB,
    performance_patterns JSONB,
    semantic_patterns JSONB,
    apriori_patterns JSONB,
    
    -- Ensemble analysis
    ensemble_analysis JSONB,
    cross_validation JSONB,
    
    -- Discovery metadata
    discovery_method VARCHAR(50) NOT NULL, -- 'hdbscan', 'fp_growth', 'apriori', 'ensemble'
    min_effectiveness FLOAT NOT NULL,
    min_support INTEGER NOT NULL,
    confidence_level FLOAT NOT NULL,
    
    -- Performance metrics
    discovery_time_ms INTEGER,
    patterns_found INTEGER DEFAULT 0,
    
    -- Timestamps
    computed_at TIMESTAMP NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL DEFAULT (NOW() + INTERVAL '24 hours'),
    last_accessed TIMESTAMP DEFAULT NOW(),
    access_count INTEGER DEFAULT 0
);

-- Store ML model predictions for rule effectiveness
CREATE TABLE IF NOT EXISTS ml_rule_predictions (
    id SERIAL PRIMARY KEY,
    prediction_key VARCHAR(255) UNIQUE NOT NULL, -- Hash of input features
    rule_id VARCHAR(50) NOT NULL,
    
    -- Input features (for reproducibility)
    prompt_characteristics JSONB NOT NULL,
    historical_context JSONB,
    
    -- ML predictions
    effectiveness_prediction FLOAT NOT NULL CHECK (effectiveness_prediction >= 0 AND effectiveness_prediction <= 1),
    confidence_interval JSONB, -- {"lower": 0.6, "upper": 0.8}
    feature_importance JSONB,
    model_version VARCHAR(50) NOT NULL,
    
    -- Prediction metadata
    prediction_method VARCHAR(50) NOT NULL, -- 'ensemble', 'gradient_boost', 'neural_network'
    training_data_size INTEGER,
    model_accuracy FLOAT,
    
    -- Timestamps
    predicted_at TIMESTAMP NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL DEFAULT (NOW() + INTERVAL '1 hour'),
    last_accessed TIMESTAMP DEFAULT NOW(),
    access_count INTEGER DEFAULT 0,
    
    -- Foreign key
    FOREIGN KEY (rule_id) REFERENCES rule_metadata(rule_id) ON DELETE CASCADE
);

-- ===================================
-- Performance Optimization Indexes
-- ===================================

-- Rule intelligence cache indexes
CREATE INDEX idx_rule_intelligence_cache_key ON rule_intelligence_cache(cache_key);
CREATE INDEX idx_rule_intelligence_rule_id ON rule_intelligence_cache(rule_id);
CREATE INDEX idx_rule_intelligence_expires_at ON rule_intelligence_cache(expires_at);
CREATE INDEX idx_rule_intelligence_total_score ON rule_intelligence_cache(total_score DESC);
CREATE INDEX idx_rule_intelligence_characteristics_hash ON rule_intelligence_cache(prompt_characteristics_hash);

-- Rule combination intelligence indexes
CREATE INDEX idx_rule_combination_key ON rule_combination_intelligence(combination_key);
CREATE INDEX idx_rule_combination_effectiveness ON rule_combination_intelligence(combined_effectiveness DESC);
CREATE INDEX idx_rule_combination_prompt_type ON rule_combination_intelligence(prompt_type);
CREATE INDEX idx_rule_combination_expires_at ON rule_combination_intelligence(expires_at);
CREATE INDEX idx_rule_combination_rule_set ON rule_combination_intelligence USING GIN (rule_set);

-- Pattern discovery cache indexes
CREATE INDEX idx_pattern_discovery_key ON pattern_discovery_cache(discovery_key);
CREATE INDEX idx_pattern_discovery_method ON pattern_discovery_cache(discovery_method);
CREATE INDEX idx_pattern_discovery_expires_at ON pattern_discovery_cache(expires_at);
CREATE INDEX idx_pattern_discovery_confidence ON pattern_discovery_cache(confidence_level DESC);

-- ML predictions indexes
CREATE INDEX idx_ml_predictions_key ON ml_rule_predictions(prediction_key);
CREATE INDEX idx_ml_predictions_rule_id ON ml_rule_predictions(rule_id);
CREATE INDEX idx_ml_predictions_model_version ON ml_rule_predictions(model_version);
CREATE INDEX idx_ml_predictions_expires_at ON ml_rule_predictions(expires_at);
CREATE INDEX idx_ml_predictions_effectiveness ON ml_rule_predictions(effectiveness_prediction DESC);

-- ===================================
-- Cache Management Functions
-- ===================================

-- Function to clean expired cache entries
CREATE OR REPLACE FUNCTION clean_expired_intelligence_cache()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER := 0;
BEGIN
    -- Clean rule intelligence cache
    DELETE FROM rule_intelligence_cache WHERE expires_at < NOW();
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    -- Clean rule combination intelligence
    DELETE FROM rule_combination_intelligence WHERE expires_at < NOW();
    GET DIAGNOSTICS deleted_count = deleted_count + ROW_COUNT;
    
    -- Clean pattern discovery cache
    DELETE FROM pattern_discovery_cache WHERE expires_at < NOW();
    GET DIAGNOSTICS deleted_count = deleted_count + ROW_COUNT;
    
    -- Clean ML predictions
    DELETE FROM ml_rule_predictions WHERE expires_at < NOW();
    GET DIAGNOSTICS deleted_count = deleted_count + ROW_COUNT;
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Function to update access statistics
CREATE OR REPLACE FUNCTION update_cache_access_stats(
    table_name TEXT,
    cache_key_value TEXT
)
RETURNS VOID AS $$
BEGIN
    CASE table_name
        WHEN 'rule_intelligence_cache' THEN
            UPDATE rule_intelligence_cache 
            SET last_accessed = NOW(), access_count = access_count + 1
            WHERE cache_key = cache_key_value;
        WHEN 'rule_combination_intelligence' THEN
            UPDATE rule_combination_intelligence 
            SET last_accessed = NOW(), access_count = access_count + 1
            WHERE combination_key = cache_key_value;
        WHEN 'pattern_discovery_cache' THEN
            UPDATE pattern_discovery_cache 
            SET last_accessed = NOW(), access_count = access_count + 1
            WHERE discovery_key = cache_key_value;
        WHEN 'ml_rule_predictions' THEN
            UPDATE ml_rule_predictions 
            SET last_accessed = NOW(), access_count = access_count + 1
            WHERE prediction_key = cache_key_value;
    END CASE;
END;
$$ LANGUAGE plpgsql;

-- ===================================
-- Views for MCP Read-Only Access
-- ===================================

-- Optimized view for rule selection
CREATE VIEW rule_selection_intelligence AS
SELECT 
    ric.rule_id,
    ric.rule_name,
    ric.effectiveness_score,
    ric.characteristic_match_score,
    ric.historical_performance_score,
    ric.ml_prediction_score,
    ric.total_score,
    ric.confidence_level,
    ric.sample_size,
    ric.pattern_insights,
    ric.optimization_recommendations,
    ric.performance_trend,
    rm.rule_category,
    rm.enabled,
    rm.priority
FROM rule_intelligence_cache ric
JOIN rule_metadata rm ON ric.rule_id = rm.rule_id
WHERE ric.expires_at > NOW()
  AND rm.enabled = true
ORDER BY ric.total_score DESC;

-- Optimized view for rule combinations
CREATE VIEW rule_combination_recommendations AS
SELECT 
    rci.rule_set,
    rci.combined_effectiveness,
    rci.synergy_score,
    rci.individual_scores,
    rci.synergy_pairs,
    rci.conflict_pairs,
    rci.statistical_confidence,
    rci.prompt_type,
    rci.domain,
    rci.complexity_range
FROM rule_combination_intelligence rci
WHERE rci.expires_at > NOW()
  AND rci.statistical_confidence >= 0.7
ORDER BY rci.combined_effectiveness DESC;

-- ===================================
-- Scheduled Cache Cleanup
-- ===================================

-- Create extension for pg_cron if available (optional)
-- This would be handled by application-level scheduling in production

COMMENT ON TABLE rule_intelligence_cache IS 'Pre-computed rule effectiveness scores for fast MCP serving';
COMMENT ON TABLE rule_combination_intelligence IS 'Pre-computed rule combination recommendations';
COMMENT ON TABLE pattern_discovery_cache IS 'Cached ML pattern discovery results';
COMMENT ON TABLE ml_rule_predictions IS 'ML model predictions for rule effectiveness';
